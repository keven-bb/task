## Test #1

### 题目
 - 统计某个 ERC20 token 下各个地址的持币情况，并且每分钟更新一次到数据库

### 思路

#### 思路1：全量更新
1. 从`token`部署的区块开始遍历
2. 筛选出 `Transfer` 事件
3. 收集事件中出现的地址（from, to）
4. 将所有地址入库
5. 遍历所有入库的地址，使用`ERC20`接口`balanceOf`查询用户余额

#### 思路2：增量更新
1. 从上次遍历到的区块开始，遍历到最近更新的区块
2. 筛选出`Transfer`事件
3. 收集事件中出现的地址（from, to）
4. 使用`ERC20`接口`balanceOf`查询用户余额
5. 更新地址余额
6. 休息1分钟，从第1步开始

#### 问题与解决
1. infura 提供的节点，最多返回`10000`条数据，超出则返回异常
    `UNI`的交易方法每次大概消耗`40000 gas`， 目前 mainnet 上每个块的`gas limit`为`12481675 gas`。
   即每个块最多能包含`200`多笔交易，为了不触发节点异常，极端条件下每个请求最多遍历`50`个块
   但是每个块不可能全部由同一`token`的交易填满，经测试，在`UNI`交易最频繁的区块中，可以遍历到`100`个块，每次最多返回不超过`8000`个块
   
2. `mysql`请求包限制(`max_allowed_packet`)
    `mysql`的默认请求包大小限制为 `4M`, 为了增加每次提交请求的效率，需要尽可能提高请求包的大小，因此会先将结果收集起来，达到一定数量后
   再提交给`mysql`。
   每条数据包含两个字段，分别是`1字节`的`id`和`40字节`的`address`，每次可提交的数据不超过`10万`条，因此大概可收到`2000`个区块的记录再提交
   
3. 多请求并发
   请求->入库->请求->入库->...
   单线程请求速度太慢，且由于以上限制，每次请求的数据数量有限，利用NodeJS的异步请求，可以有效提高效率，举例如下：
   目标：遍历1万个块
   - 将请求切割，每`2000`个块为一个`任务块`，共有`5`个任务块
   - 将`任务块`切分成`任务`，每`100`个块为一个任务，此时共有`20`个任务
   - 将`20`个任务同时请求，等待`20`个`任务`完成
   - 聚合`20`个任务的请求结果
   - 将聚合后的结果入库
   - 再遍历下一个任务块
   
#### 使用说明

环境：
   - nodejs v12.14.0
   - mysql v5.7
   - docker

使用前置：
   - 启用mysql：`docker run --name bybit-task -e MYSQL_ROOT_PASSWORD=secret -e MYSQL_DATABASE=bybit -p 3306:3306 -d --rm mysql:5.7`
   - 安装依赖：`yarn`
   - 迁移表数据：`yarn db-migrate up`

使用命令：
   - `yarn update $token $from`
      - 说明：从`from`块开始更新`token`的交互地址
      - 参数：
            - `$token`：`token` 地址
            - `$from`：`from` 开始遍历的块
        
   - `yarn monitor $token`
        - 说明：增量更新，每分钟更新一次（可配置）
        - 参数：
            - `$token`: `token`地址，必须之前执行过增量更新
    
        
   - `yarn test`
        - 说明：执行单元测试
